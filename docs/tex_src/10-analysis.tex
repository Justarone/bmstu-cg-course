\chapter{Аналитическая часть}

\section{Формальное описание геометрической модели мышцы}

Ввиду сложности прямого описания поверхности мышцы некоторым уравнением, модель мышцы в данной работе будет представляться с помощью группы усечённых конусов, полученной путем вращения группы отрезков, находящихся между узлами модели. Очевидно, что при такой модели радиусы основания конуса описываются значениями точек начала и конца отрезка, которые далее будут называться \textit{радиусом узла}.

Для упрощения работы с моделью расстояние между узлами было выбрано постоянным. Данный факт не вносит никаких ограничений в представление модели, так как, описывая некоторый узел пропорционально соседям этого узла, получается представление, в котором визуально расстояние между этими двумя соседними узлами будет удвоено. С помощью этих действий выводится расстояние между двумя произвольными узлами.

Учитывая описанное выше, для исчерпывающего описания состояния и положения мыщцы требуется, во-первых, массив радиусов оснований конусов в узлах, а во-вторых, расстояние между узлами.

Однако для исчерпывающего описания свойств мыщцы этого мало. Такой набор не хранит информации о поведении узлов при деформациях, поэтому также для каждого узла требуется добавить коэффициент приращения, который будет означать относительный прирост данного узла.
\begin{itemize}
    \item массив радиусов узлов;
    \item расстояние между узлами;
    \item массив коэффициентов прироста радиусов узлов.
\end{itemize}

\section{Расчёт формул деформации мышцы}

Как уже было сказано выше, общий объем модели составляется из объемов составляющих ее усечённых конусов, объем которых вычисляется как фигура вращения отрезка. 

Отрезок в данном случае проще всего задавать в виде прямой, заданной уравнением $ y = ax + b $, которая ограничена по \textit{x}: $x \in [0; \Delta x]$, где $\Delta x$ - расстояние между узлами. Рассматривать для $i$-ого и $(i + 1)$-ого узлов отрезок $[0; \Delta x]$ гораздо проще, чем отрезок $[(i - 1) \cdot \Delta x; i \cdot \Delta x]$, в связи с чем во всех последующих вычислениях подразумевается, что пара соседних узлов с индексами $i$ и $(i + 1)$ сдвигается на $(i - 1) \cdot \Delta x$ влево (можно заметить, что во всех последующих расчетах нас будет интересовать исключительно величина $\Delta x$, поэтому все последующие расчёты справделивы и для исходного положения составных частей модели). Площадь усечённого конуса в таком случае можно рассчитывать по формуле (\ref{for:area_rotate}):
\begin{equation}
    \label{for:area_rotate}
    \mathcal{V} = \pi \cdot \int_{0}^{\Delta x}f^2(x)dx,\qquad \text{где }f(x) = ax + b
\end{equation}

Далее можно подставить значение функции и рассчитать интеграл (\ref{for:area_opened}):
\begin{equation}
    \label{for:area_opened}
    \mathcal{V} = \pi \cdot \int_{0}^{\Delta x}\left(a^2x^2 + 2abx + b^2\right)dx = \pi \cdot \left(\frac{a^2x^3}{3} + abx^2 + b^2x\right)\Biggr|_{0}^{\Delta x}
\end{equation}

Из чего следует (\ref{for:open_limits}):
\begin{equation}
    \label{for:open_limits}
    \mathcal{V} = \pi \cdot \left(\frac{a^2\Delta x^3}{3} + ab\Delta x^2 + b^2\Delta x\right)
\end{equation}

Коэффициенты $a$ (угла наклона прямой) и $b$ (точки пересечения прямой с $Oy$) можно найти исходя из двух имеющихся точек отрезка. Так, для отрезка между $i$-ым и $(i+1)$-ым узлами, получается (\ref{for:coeffa}) и (\ref{for:coeffb}):
\begin{equation}
    \label{for:coeffa}
    a = \frac{y_{i+1} - y_{i}}{\Delta x}
\end{equation}

\begin{equation}
    \label{for:coeffb}
    b = y_i
\end{equation}

Пусть $n$ - кол-во узлов. Тогда $R = \{ r_1, r_2, \ldots r_n \}$ - массив радиусов узлов, $M = \{ m_1, m_2, \ldots, m_n \}$ - массив коэффициентов прироста радиусов узлов. Отсюда (учитывая формулы (\ref{for:open_limits}), (\ref{for:coeffa}) и (\ref{for:coeffb})) получается, что общий объем, для удобства последующих вычислений поделённый на $\pi$, можно вычислить по формуле (\ref{for:total_volume}):
\begin{equation}
    \label{for:total_volume}
    V = \frac{\mathcal{V}}{\pi} = \sum_{i=1}^{n-1} \left(\frac{(r_{i + 1} - r_i)^2 \cdot \Delta x}{3} + 2 r_i (r_{i + 1} - r_i) \cdot \Delta x + r_i^2 \Delta x \right)
\end{equation}

После выноса за знак суммы $\Delta x$ получается итоговая формула вычисления объема (\ref{for:total_volume_no_x}):

\begin{equation}
    \label{for:total_volume_no_x}
    V = \Delta x \cdot \sum_{i=1}^{n-1} \left(\frac{(r_{i + 1} - r_i)^2}{3} + 2 r_i (r_{i + 1} - r_1) + r_i^2 \right)
\end{equation}

Которую можно представить как функцию от расстояния между узлами $\Delta x$ и массива радиусов узлов (\ref{for:v_from_rads_dx}):
\begin{equation}
    \label{for:v_from_rads_dx}
    V(\Delta x, R) = \Delta x \cdot F(R), 
\end{equation}

где $F(R)$ - функция (\ref{for:f_r}):

\begin{equation}
    \label{for:f_r}
    F(R) = \sum_{i=1}^{n-1} \left(\frac{(r_{i + 1} - r_i)^2}{3} + 2 r_i (r_{i + 1} - r_1) + r_i^2 \right)
\end{equation}


Длина модели $L$ является суммой расстояний между узлами и для $n$ узлов находится следующим образом (\ref{for:len}):
\begin{equation}
    \label{for:len}
    L = (n - 1) \cdot \Delta x
\end{equation}

Откуда можно вывести зависимость расстояния между узлами от длины (\ref{for:del_from_len}):
\begin{equation}
    \label{for:del_from_len}
    \Delta x = \frac{L}{n - 1}
\end{equation}

При деформации модели (сокращении или растяжении) объем должен оставаться постоянным. Если посмотреть на выражение (\ref{for:v_from_rads_dx}) становится очевидным, что для равенства $V = V'$, где $V$ - объем до деформации, а $V'$ - после, должно выполнятся равенство (\ref{for:alter_eq}):
\begin{equation}
    \label{for:alter_eq}
    \Delta x \cdot F(R) = \Delta x' \cdot F(R')
\end{equation}

где $R'$ - массив радиусов узлов после деформации, $\Delta x'$, учитывая (\ref{for:del_from_len}), находится из (\ref{for:new_delta}):
\begin{equation}
    \label{for:new_delta}
    \Delta x' = \frac{L'}{n - 1} = \frac{L + \delta x}{n - 1} = \Delta x + \frac{\delta x}{n - 1}
\end{equation}

где $\delta x$ - изменение длины, а $L' = L + \delta x$ - новое значение длины модели.

Отсюда получается, что $F(R')$ можно найти, как (\ref{for:new_r}):
\begin{equation}
    \label{for:new_r}
    F(R') = \frac{F(R) \cdot \Delta x}{\Delta x'} = \frac{\Delta x}{\Delta x'} \cdot F(R)
\end{equation}

Пусть $\delta y$ - элементарное приращение радиуса. Тогда новое значение для радиуса каждого узла можно найти из соотношения:
\begin{equation}
    \label{for:new_rad}
    r_i' = r_i + m_i \cdot \delta y
\end{equation}
где $m_i$ (как было описано выше) - коэффициент прироста радиуса.

Таким образом можно выразить через (\ref{for:new_rad}) радиусы массива $R'$ и найти $F(R')$ как (\ref{for:f_r_new}):
\begin{equation}
    \label{for:f_r_new}
    \begin{split}
        F(R') = \sum_{i=1}^{n-1} (\frac{((r_{i + 1} + m_{i + 1} \cdot \delta y) - (r_i + m_{i} \cdot \delta y))^2}{3} + \\
        + 2 (r_i + m_i \cdot \delta y) \cdot (r_{i + 1} + m_{i + 1} \cdot \delta y - r_i + m{i} \cdot \delta y) + (r_i + m_i \cdot \delta y)^2)
    \end{split}
\end{equation}

После приведения подобных слагаемых относительно $\delta y$ получается (\ref{for:f_r_final}):
\begin{equation}
    \label{for:f_r_final}
        F(R') = A \delta y^2 + B \delta y + C,
\end{equation}

где $A$, $B$, $C$ рассчитываются из (\ref{for:coeffA}), (\ref{for:coeffB}), (\ref{for:coeffC}) соответственно.

\begin{equation}
    \label{for:coeffA}
    A = \sum_{i=1}^{n-1}\left(\frac{1}{3}m_{i + 1}^2 - \frac{5}{3}m_{i + 1}m_i + \frac{7}{3}m_i^2 \right)
\end{equation}

\begin{equation}
    \label{for:coeffB}
    B = \sum_{i=1}^{n-1}\left(m_{i + 1}r_i + m_ir_{i + 1} \right)
\end{equation}

\begin{equation}
    \label{for:coeffC}
    C = \sum_{i=1}^{n-1}\left(\frac{(r_{i + 1} - r_i)^2}{3} + r_{n + 1}r_n\right)
\end{equation}

Квадратное уравнение (\ref{for:f_r_final}) будет иметь решения (\ref{for:quad_sol}):
\begin{equation}
    \label{for:quad_sol}
    \delta y_{1, 2} = \frac{-B \pm \sqrt{B^2 - 4AC}}{2A}
\end{equation}

Среди решений больший интерес представляет большее, потому что меньшее решение находит сохранение объема при отрицательных радиусах, что не является верных в рамках имеющейся задачи. Таким образом $\delta y$ - больший корень среди корней из (\ref{for:quad_sol}), который равен (\ref{for:quad_sol_one}):
\begin{equation}
    \label{for:quad_sol_one}
    \delta y = \frac{-B + \sqrt{B^2 - 4AC}}{2A}
\end{equation}

Таким образом при деформации модели на величину $\delta x$ новые значения радиусов узлов будут иметь вид (\ref{for:new_rad}), где величина $\delta y$ находится из выражения (\ref{for:quad_sol_one}).

\section{Формальное описание геометрической модели каркаса мышцы}

В данной работе каркас будет отождествляться с 2 стержнями, соединенными вместе концами. Положение каркаса зависит от положения и состояния модели мышцы, однако есть параметры, которые от нее не зависят - точки крепления. Для представления каркаса будет достаточно следующих параметров:
\begin{itemize}
    \item расстояние от нескрепленного конца первого стержня до точки крепления мышцы;
    \item расстояние от точки крепления мышцы к первому стержню до точки соединения стержней;
    \item расстояние от точки соединения стержней до точки крепления мышцы ко второму стержню;
    \item расстояние от точки крепления мышцы ко второму стержню до нескрепленного конца второго стержня;
\end{itemize}

Углы наклона стержней каркаса будут находится из теоремы косинусов, которая для треугольника с длинами сторон $A$, $B$, $C$ и угла $\alpha$, лежащего напротив стороны с длиной $A$, будет иметь вид (\ref{for:cos_th}):
\begin{equation}
    \label{for:cos_th}
    A^2 = B^2 + C^2 - 2BC \cos(\alpha)
\end{equation}

Откуда можно выразить угол $\alpha$ как (\ref{for:angle_from_th}):
\begin{equation}
    \label{for:angle_from_th}
    \alpha = \arccos{\left(\frac{B^2 + C^2 - A^2}{2BC}\right)}
\end{equation}

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

При выборе алгоритма удаления невидимых линий и поверхностей нужно учесть особенность поставленной задачи - работа программы будет выполняться в реальном режиме при взаимодействии с пользователем. Этот факт предъявляет к алгоритму требование по скорости работы. Для выбора наиболее подходящего алгоритма следует рассмотреть уже имеющиеся алгоритмы удаления невидимых линий и поверхностей.

\subsection{Алгоритм обратной трассировки лучей}
Алгоритм работает в пространстве изображения.

Идея: для определения цвета пиксела экрана через него из точки наблюдения проводится луч, ищется пересечение первым пересекаемым объектом сцены и определяется освещенность точки пересечения. Эта освещенность складывается из отраженной и преломленной энергий, полученных от источников света, а также отраженной и преломленной энергий, идущих от других объектов сцены. После определения освещенности найденной точки учитывается ослабление света при прохождении через прозрачный материал и в результате получается цвет точки экрана.

Плюсы:
\begin{itemize}
    \item качественное изображение, которое может быть построено с учётом явлений дисперсии лучей, преломления, а также внутреннего отражения;
    \item возможность использования в параллельных вычислительных системах.
\end{itemize}

Минусы:
\begin{itemize}
    \item трудоёмкие вычисления;
    \item высокая сложность реализации версии, учитывающей все физические явления.
\end{itemize}

\textbf{Вывод:} так как в поставленной задаче в первую очередь стоит требование быстроты работы алгоритма, а также ввиду того, что модели, использующиеся в программе, не являются прозрачными и имеют преимущественно диффузное отражение, данный алгоритм не подходит в рамках данной работы.

\subsection{Алгоритм, использующий Z-буфер}
Алгоритм работает в простанстве изображения.

Идея: имеется 2 буфера - буфер кадра, который используется для запоминания цвета каждого пиксела изображения, а также $z$-буфер - отдельный буфер глубины, используемый для запоминания координаты $z$ (глубины) каждого видимого пиксела изображения. В процессе работы глубина или значение $z$ каждого нового пиксела, который нужно занести в буфер кадра, сравнивается с глубиной того пиксела, который уже занесен в $z$-буфер. Если это сравнение показывает, что новый пиксел расположен выше пиксела, находящегося в буфере кадра ($z > 0$), то новый пиксел заносится в цвет рассматриваемого пиксела заносится в буфер кадра, а координата $z$ - в $z$-буфер. По сути, алгоритм является поиском по $x$ и $y$ наибольшего значения функции $z(x, y)$.

Плюсы:
\begin{itemize}
    \item простота реализации;
    \item простота работа со сложными поверхностями;
    \item отсутствие требования сортировки объектов по глубине;
    \item высокая скорость работы.
\end{itemize}

Минусы:
\begin{itemize}
    \item требование большого объема памяти (в рамках современных вычислительных систем несущественно);
    \item сложность работы с прозрачными и просвечивающими объектами.
\end{itemize}

\textbf{Вывод:} ввиду того, что алгоритм удовлетворяет главному требованию программы, а его минусы не входят в число требований к программе, данный алгоритм может быть выбран в качестве алгоритма удаления невидимых линий и поверхностей в данной работе.

\subsection{Алгоритм Робертса}
Алгоритм работает в объектном пространстве. 

Идея: алгоритм прежде всего удаляет из каждого тела те ребра или грани, которые экранируются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, экранируются этими телами. 

Плюсы:
\begin{itemize}
    \item простые, но при этом точные математические методы;
    \item реализации алгоритма, использующие предварительную приоритетную сортировку вдоль оси z и простые габаритные или минимаксные тесты, демонстрируют почти линейную зависимость от числа объектов.
\end{itemize}

Минусы:
\begin{itemize}
    \item вычислительная трудоёмкость алгоритма теоретически растет, как квадрат числа объектов;
    \item большое количество этапов обработки и предварительных вычислений (из чего следует большое количество кода и высокая асимптотическая константа);
    \item отсутствие возможности работы с прозрачными и просвечивающими объектами.
\end{itemize}

\textbf{Вывод:} данный алгоритм сложен в реализации в виду большого количества требуемых оптимизаций, а так же будет работать медленнее с аппроксимированными фигурами вращения, нежели со стандартными многогранниками, что приведет к медленной работе и не будет удовлетворять главному требованию программы.

\subsection*{Вывод}
Ввиду требования к быстрой работе алгоритма, а так же большого количества плоскостей, получающихся при аппроксимации фигур вращения и замедляющих алгоритмы, работающие в объектном пространстве, рациональным выбором будет выбор алгоритма z-буфера в качестве алгоритма удаления невидимых линий и поверхностей.


\section{Анализ методов закрашивания}

Методы закрашивания используются для затенения полигонов (или поверхностей, аппроксимированных полигонами) в условиях некоторой сцены, имеющей источники освещения. С учётом взаимного положения рассматриваемого полигона и источника света находится уровень освещенности по закону Ламберта (\ref{for:lambert}):
\begin{equation}
    \label{for:lambert}
    I_{\alpha} = I_0 \cdot \cos{(\alpha)}
\end{equation}

где $I_{\alpha}$ - уровень освёщенности в рассматриваемой точке, $I_0$ - максимальный уровень освёщенности, а $\alpha$ - угол между вектором нормали к плоскости и вектором, направленным от рассматриваемой точки к источнику освещения (в случае нормированных векторов может быть рассчитан как скалярное произведение данных векторов).

\subsection{Простая закраска}

Идея: вся грань закрашивается одним уровнем интенсивности, который зависит высчитывается по закону Ламберта. При данной закраске все плоскости (в том числе и те, что аппроксимируют фигуры вращения), будут закрашены однотонно, что в случае с фигурами вращения будет давать ложные ребра.

Плюсы:
\begin{itemize}
    \item быстрая работа;
    \item хорошо подходит для многогранников, обладающих преимущественно диффузным отражением.
\end{itemize}

\begin{itemize}
    \item плохо подходит для фигур вращения: видны ребра.
\end{itemize}

\textbf{Вывод:} учитывая, что в рамках данной работы все модели - фигуры вращения, данных алгоритм не является подходящим.

\subsection{Закраска по Гуро}
Идея: билинейная интерполяция в каждой точке интенсивности освещения в вершинах.

Нормаль к вершине можно найти несколькими способами:
\begin{itemize}
    \item интерполировать нормали прилегающих к вершине граней;
    \item использовать геометрические свойства фигуры (так, например, в случае со сферой ненормированный вектор нормали будет в точности соответствовать вектору от центра сферы до рассматриваемой точки).
\end{itemize}

После нахождения нормали ко всем вершинам находится интенсивность в каждой вершине по закону Ламберта (\ref{for:lambert}).
Затем алгоритм проходится сканирующими строками по рассматриваемому полигону для всех $y: y \in [y_{min}; y_{max}]$. Каждая сканирующая строка пересекает 2 ребра многоугольника, пусть для определённости это будут ребра через одноименные вершины: $MN$ и $KL$. В точках пересечения высчитывается интенсивность путём интерполяции интенсивности в вершинах. Так, для точки пересечения с ребром $MN$ интенсивность будет рассчитана как (\ref{for:int_mn}):
\begin{equation}
    \label{for:int_mn}
    I_{MN} = \frac{l_1}{l_0} \cdot I_M + \frac{l_2}{l_0} \cdot I_N
\end{equation}
где $l_1$ - расстояние от точки пересечения до вершины $N$, $l_2$ - расстояние от точки пересечения до вершины $M$, $l_0$ - длина ребра $MN$.
Для точки пересечения сканирующей строки с ребром $KL$ интенсивность высчитывается аналогично.

Далее, после нахождения точек пересечения, алгоритм двигается по $Ox$ от левой точки пересечения $X_{left}$ до правой точки пересечения $X_{right}$ и в каждой точке $\mathcal{X}$ интенсивность рассчитывается как (\ref{for:int_x}):
\begin{equation}
    \label{for:int_x}
    I_{\mathcal{X}} = \frac{\mathcal{X} - X_{left}}{X_{right} - X_{left}} \cdot I_{X_{right}} + \frac{X_{right} - \mathcal{X}}{X_{right} - X_{left}} \cdot I_{X_{left}}
\end{equation}

Плюсы:
\begin{itemize}
    \item хорошо подходит для фигур вращения, аппроксимированных полигонами, с диффузным отражением.
\end{itemize}

Минусы:
\begin{itemize}
    \item при закраске многогранников ребра могут стать незаметными.
\end{itemize}

\textbf{Вывод:} с учетом наличия в данной работе исключительно фигур вращения данных алгоритм подходит гораздо больше предыдущего.


\subsection{Закраска по Фонгу}
Идея: данный алгоритм работает похожим на алгоритм Гуро образом, однако ключевым отличием является то, что интерполируются не интенсивности в вершинах, а нормали. Таким образом, закон Ламберта в данном алгоритме применяется в каждой точке, а не только в вершинах, что делает этот алгоритм гораздо более трудоёмким, однако с его помощью можно гораздо лучше изображаются блики.

Плюсы:
\begin{itemize}
    \item хорошо отображает блики, вследствие чего подходит для закраски фигур с зеркальным отражением.
\end{itemize}

Минусы:
\begin{itemize}
    \item самый трудоёмкий алгоритм из рассмотренных.
\end{itemize}

\subsection*{Вывод}

Ввиду требования к быстрой работе алгоритма, а так же большого наличия исключительно моделей с диффузным отражением, рациональным выбором будет выбор алгоритма закраски Гуро в качестве метода закрашивания.


\section*{Вывод}

В данном разделе были формально описаны модели мышцы, каркаса и законы, по которым эти модели деформируются, были рассмотрены алгоритмы удаления невидимых линий и поверхностей, методы закрашивания поверхностей. В качестве алгоритма удаления невидимых линий и поверхностей был выбран алгоритм z-буфера, в качестве метода закрашивания был выбран алгоритм закраски Гуро.
